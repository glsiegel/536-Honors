package interpreter;

import java.util.ArrayList;
import java.util.List;

import data.*;
import data.Expr.*;
import data.Stmt.*;
import env.GlobalEnvironment;
import error.VisitorError;

/**
 * Visitor which makes a best effort to build global environments for the
 * interpreter. Additionally, captures any issues in building a global
 * environment. This is most important for if we have a non-singleton file we
 * are checking. In this manner, before we check ANY files, we can first
 * evaluate all the globals of all files. Then, the checker can easily grab the
 * global variables and functions from any file. This also lets us have
 * dependency cycles, which is a feature I wanted in the language.
 * 
 * In building the globals, the interpreter requires for global variables to be
 * declared with a "simple" expression, meaning one which only uses literals,
 * previously-defined global variables within the same file, and any operations.
 * This is a technical limitation. If not, then we would have to check at the
 * same time as constructing globals, which would make dependency cycles much
 * more difficult to manage. To get around this, users may have to call special
 * "setup" functions that will initialize globals to intended values.
 */
public class GlobalValueBuilder implements Expr.Visitor<Object>, Stmt.Visitor<Void> {

	/**
	 * Built globals.
	 */
	public final GlobalEnvironment<Object> globals = new GlobalEnvironment<>();
	/**
	 * Errors encountered in building.
	 */
	public final List<VisitorError> visitorErrors = new ArrayList<>();

	/**
	 * Construct a new GlobalValueBuilder.
	 */
	public GlobalValueBuilder() {

	}

	/**
	 * Runs the GlobalValueBuilder on a parsed list of statements.
	 * 
	 * @param statements parsed list of statements
	 */
	public void run(List<Stmt> statements) {
		for (Stmt stmt : statements) {
			stmt.accept(this);
		}
	}

	@Override
	public Void visitBlockStmt(Block stmt) {
		return null;
	}

	@Override
	public Void visitExpressionStmt(Expression stmt) {
		return null;
	}

	@Override
	public Void visitFunctionStmt(Function stmt) {
		// put into globals
		if (!globals.putFunction(stmt)) {
			visitorErrors.add(VisitorError.New(stmt, "Function exists with this name."));
		}
		return null;
	}

	@Override
	public Void visitIfStmt(If stmt) {
		return null;
	}

	@Override
	public Void visitPrintStmt(Print stmt) {
		return null;
	}

	@Override
	public Void visitReturnStmt(Return stmt) {
		return null;
	}

	@Override
	public Void visitVarStmt(Var stmt) {
		if (!globals.put(stmt.name, stmt.initializer.accept(this), false)) {
			visitorErrors.add(VisitorError.New(stmt, "Global variable exists with this name."));
		}
		return null;
	}

	@Override
	public Void visitAssignStmt(Assign stmt) {
		return null;
	}

	@Override
	public Void visitWhileStmt(While stmt) {
		return null;
	}

	@Override
	public Void visitImportStmt(Import stmt) {
		if (!globals.importRootpathAs(stmt.name, stmt.rootpath)) {
			visitorErrors.add(VisitorError.New(stmt, "Name with this import already exists."));
		}
		return null;
	}

	@Override
	public Void visitAsStmt(As stmt) {
		return null;
	}

	@Override
	public Object visitBinaryExpr(Expr.Binary expr) {
		// Evaluate left and right operands, then apply the operator
		// Handle arithmetic (+, -, *, /), comparison (==, !=, <, <=, >, >=), and
		// logical (&&, ||) operators

		Object leftObj = expr.left.accept(this);
		Object rightObj = expr.right.accept(this);

		switch (expr.operator) {
		// first look at the ones that require two integers
		case PLUS, MINUS, MULTIPLY, DIVIDE, LESS, GREATER, LESS_EQUAL, GREATER_EQUAL -> {
			if (!(leftObj instanceof Integer && rightObj instanceof Integer)) {
				throw new RuntimeException("Operator " + expr.operator + " requires two numbers.");
			}

			Integer left = (Integer) leftObj;
			Integer right = (Integer) rightObj;

			// we have the integers, now just compute
			if (expr.operator == Operator.PLUS)
				return left + right;
			else if (expr.operator == Operator.MINUS)
				return left - right;
			else if (expr.operator == Operator.MULTIPLY)
				return left * right;
			else if (expr.operator == Operator.DIVIDE)
				return left / right;
			else if (expr.operator == Operator.LESS)
				return left < right;
			else if (expr.operator == Operator.GREATER)
				return left > right;
			else if (expr.operator == Operator.LESS_EQUAL)
				return left <= right;
			else if (expr.operator == Operator.GREATER_EQUAL)
				return left >= right;
		}
		// second look at the ones that take two bools
		case OR, AND -> {
			if (!(leftObj instanceof Boolean && rightObj instanceof Boolean)) {
				throw new RuntimeException("Operator " + expr.operator + " requires two booleans.");
			}

			Boolean left = (Boolean) leftObj;
			Boolean right = (Boolean) rightObj;

			// we have the bools, just compute
			if (expr.operator == Operator.OR) {
				return left || right;
			} else if (expr.operator == Operator.AND) {
				return left && right;
			}
		}
		// lastly, look at the ones that take any two types: equality and inequality
		case EQUAL -> {
			return leftObj.equals(rightObj);
		}
		case NOT_EQUAL -> {
			return !leftObj.equals(rightObj);
		}
		default -> throw new RuntimeException("Operator " + expr.operator + " not implemented for binary.");

		}

		return null; // never gets here
	}

	@Override
	public Object visitLiteralExpr(Literal expr) {
		// TODO Auto-generated method stub
		return expr.value;
	}

	@Override
	public Object visitUnaryExpr(Expr.Unary expr) {
		// Evaluate the right operand and apply the unary operator (!, -)
		Object val = expr.right.accept(this);

		// go through the operators
		// only two are valid for unary, so the rest should error
		switch (expr.operator) {
		case MINUS:
			// minus requires an integer. otherwise throw error
			if (!(val instanceof Integer)) {
				throw new RuntimeException("Can only use " + expr.operator + " on numbers");
			}
			Integer intVal = (Integer) val;
			return -intVal;
		case NOT:
			// not requires a bool. otherwise throw error
			if (!(val instanceof Boolean)) {
				throw new RuntimeException("Can only use " + expr.operator + " on booleans");
			}
			Boolean boolVal = (Boolean) val;
			return !boolVal;
		default:
			throw new RuntimeException("Unary not implemented for " + expr.operator);
		}
	}

	@Override
	public Object visitVariableExpr(Expr.Variable expr) {
		if (globals.has(expr.name)) {

		}
		visitorErrors.add(VisitorError.New(expr,
				"Globals cannot be initialized with a variable call. Use simple expressions with literals."));
		return 0;
	}

	@Override
	public Object visitCallExpr(Call expr) {
		visitorErrors.add(VisitorError.New(expr,
				"Globals cannot be initialized with a function call. Use simple expressions with literals."));
		return 0;
	}

	@Override
	public Object visitIndirectExpr(Indirect expr) {
		visitorErrors.add(VisitorError.New(expr,
				"Globals cannot be initialized with an indirection to other globals. Use simple expressions with literals."));
		return 0;
	}

}
