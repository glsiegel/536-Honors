package edu.pipeline;

import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

import org.eclipse.lsp4j.SemanticTokens;

import checker.Checker;
import checker.GlobalTypeBuilder;
import edu.data.CodeSection;
import edu.data.Outcome;
import edu.data.Stmt;
import edu.data.Token;
import edu.data.VarType;
import edu.error.IError;
import edu.error.LexerError;
import edu.lexer.Lexer;
import edu.parser.Parser;

/**
 * Static class that allows for running different parts of the checker.
 * 
 */
public class Pipeline {
	/**
	 * From string contents of a file, gets the list of statements in the form of
	 * StatementData. StatementData contains a list of errors along with the list of
	 * statements. If there are any huge unrecoverable problems, statements will be
	 * null and errors will be recorded. Otherwise, statements will have a value,
	 * and errors are recorded in any event.
	 * 
	 * @param contents the string file contents
	 * @return StatementData structure
	 */
	public static StatementData getStatements(String contents) {
		Lexer lexer = new Lexer();
		try {
			lexer.runOnString(contents);
		} catch (Exception e) {
			return new StatementData(null, lexer.errors);
		}

		if (lexer.tokenList == null) {
			return new StatementData(null, lexer.errors);
		}
		// aggregate errors
		List<edu.error.IError> aggregate = new ArrayList<edu.error.IError>();
		aggregate.addAll(lexer.errors);

		List<Token> token_list = lexer.tokenList;
		Parser parser = new Parser(token_list);

		try {

			parser.run();
		} catch (Exception e) {

			aggregate.addAll(parser.errors);
			return new StatementData(null, aggregate);
		}

		aggregate.addAll(parser.errors);

		if (parser.hasAs()) {
			return new StatementData(parser.statements, aggregate, parser.getRootpath());
		} else {
			return new StatementData(parser.statements, aggregate);
		}
	}

	/**
	 * From a file, gets the list of statements in the form of StatementData.
	 * StatementData contains a list of errors along with the list of statements. If
	 * there are any huge unrecoverable problems, statements will be null and errors
	 * will be recorded. Otherwise, statements will have a value, and errors are
	 * recorded in any event.
	 * 
	 * @param file the file
	 * @return StatementData structure
	 */
	public static StatementData getStatements(File file) {
		Lexer lexer = new Lexer();
		try {

			lexer.runOnFile(file.getAbsolutePath());

		} catch (Exception e) {
			return new StatementData(null, lexer.errors);
		}

		if (lexer.tokenList == null)
			return new StatementData(null, lexer.errors);
		// aggregate errors
		List<edu.error.IError> aggregate = new ArrayList<edu.error.IError>();
		aggregate.addAll(lexer.errors);

		List<Token> token_list = lexer.tokenList;
		Parser parser = new Parser(token_list);

		try {

			parser.run();
		} catch (Exception e) {

			aggregate.addAll(parser.errors);
			return new StatementData(null, aggregate);
		}

		aggregate.addAll(parser.errors);

		if (parser.hasAs()) {
			return new StatementData(parser.statements, aggregate, parser.getRootpath());
		} else {
			return new StatementData(parser.statements, aggregate);
		}
	}

	/**
	 * From a list of statements, runs the global builder. The global builder
	 * discerns the globals in the file. In particular, it determines the functions
	 * and global variables. This is important so that all files can know what
	 * globals are available BEFORE the checker runs.
	 * 
	 * @param statements list of statements to run on
	 * @return GlobalBuilder object
	 */
	public static GlobalTypeBuilder runGlobalBuilder(List<Stmt> statements) {
		GlobalTypeBuilder globalBuilder = new GlobalTypeBuilder();
		globalBuilder.run(statements);
		return globalBuilder;
	}

	/**
	 * From a list of statements, runs the checker. This will provide the Checker
	 * object, which stores all the errors present. If a rootpath and file manager
	 * are not given, then this file is treated as a singleton. Otherwise, it is
	 * acknowledged as a part of a larger collective.
	 * 
	 * @param statements the list of statements to check
	 * @param rootpath   nullable, the rootpath of the file or null if singleton
	 * @param manager    nullable, the manager of the file or null if singleton
	 * @return Checker containing the errors
	 */
	public static Checker runChecker(List<Stmt> statements, Rootpath rootpath, FileManager<VarType> manager) {
		Checker checker;
		if (rootpath == null || manager == null) {
			checker = new Checker();
		} else {
			checker = new Checker(rootpath, manager);
		}

		checker.runChecker(statements);
		return checker;
	}

	public static Outcome runStaticCheck(File f) {
		List<IError> error_aggregate = new ArrayList<IError>();
		if (!f.exists()) {
			error_aggregate
					.add(new LexerError(CodeSection.ZERO, String.format("Could not find file '%s'.", f.getName())));
			return new Outcome(new StatementData(null, error_aggregate));
		}
		StatementData data = Pipeline.getStatements(f);
		error_aggregate.addAll(data.errors);
		if (data.statements == null)
			return new Outcome(data); // error propigate

		if (data.rootpath == null) {
			// rootpath is null! we are singleton.
			// just do checker
			Checker checker = Pipeline.runChecker(data.statements, null, null);
			error_aggregate.addAll(checker.visitorErrors);

			// bastardization of this class but it's a good container
			StatementData our_last_data = new StatementData(data.statements, error_aggregate);

			return new Outcome(our_last_data);
		}

		// not singleton
		FileManager<VarType> manager = new FileManager<>(data.rootpath, f);
		// TODO add here
		manager.pullInFile(data.rootpath, true);
		GlobalTypeBuilder gtb = new GlobalTypeBuilder();
		gtb.run(data.statements);
		error_aggregate.addAll(gtb.visitorFailures);
		manager.indicateEvaluation(data.rootpath, error_aggregate, data.statements, gtb.globals, null);
		List<Rootpath> rootpaths_to_pull = new ArrayList<Rootpath>();

		rootpaths_to_pull.addAll(gtb.rootpaths_to_pull_in);
		while (!rootpaths_to_pull.isEmpty()) {
			Rootpath curr = rootpaths_to_pull.removeFirst();

			if (manager.has(curr))
				continue;

			FileInfo<VarType> fileinfo = manager.pullInFile(curr, false);
			if (fileinfo == null) {
				error_aggregate.add(new edu.error.VisitorError(new CodeSection(0, 0, 0, 0),
						String.format("Could not find file at %s.", curr)));
				continue;
			}
			List<IError> curr_errors = new ArrayList<>();
			// first, we will get the globals for the file.
			StatementData curr_data = Pipeline.getStatements(fileinfo.file);

			curr_errors.addAll(curr_data.errors);

			if (curr_data.statements == null) {
				manager.indicateEvaluation(curr, curr_errors, null, null, null);
				continue; // go to next in the loop
			}

			GlobalTypeBuilder curr_gtb = Pipeline.runGlobalBuilder(curr_data.statements);
			curr_errors.addAll(curr_gtb.visitorFailures);
			manager.indicateEvaluation(curr_data.rootpath, curr_errors, curr_data.statements, curr_gtb.globals, null);

		}

		// great, so we should have globals indicated for all of them that don't have
		// terrible errors. If they do have errors, we have to ignore.

		// run checker on each that have statements
		// otherwise, just show the errors and stop
		for (Iterator<Map.Entry<Rootpath, FileInfo<VarType>>> iterator = manager.uncheckedIterator(); iterator.hasNext(); ) {
			Map.Entry<Rootpath, FileInfo<VarType>> entry = iterator.next();
			Rootpath rootpath = entry.getKey();
			FileInfo<VarType> fileinfo = entry.getValue();
			File our_file = fileinfo.file;
			String our_uri = our_file.toURI().toString();
			List<Stmt> statements = fileinfo.getStatements();
			if (statements == null) {
				continue;
			}
			Checker checker = Pipeline.runChecker(statements, rootpath, manager);
			List<edu.error.IError> our_errors = new ArrayList<>();

			our_errors.addAll(fileinfo.getErrors());
			our_errors.addAll(checker.visitorErrors);

			// TODO this is messy as hell.
			manager.indicateEvaluation(rootpath, our_errors, fileinfo.getStatements(), fileinfo.getGlobals(),
					checker.semanticTokens);

		}

		return new Outcome(manager);
	}

}
