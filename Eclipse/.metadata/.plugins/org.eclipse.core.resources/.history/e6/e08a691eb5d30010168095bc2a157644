package data;

import java.util.List;

/**
 * Expression class, modified to also take in a CodeSection.
 */
public abstract class Expr {
	/**
	 * The section containing this expression.
	 */
	public final CodeSection section;

	/**
	 * General expression constructor so that others can call super easily.
	 * 
	 * @param section the section containing this expression
	 */
	public Expr(CodeSection section) {
		this.section = section;
	}

	public interface Visitor<R> {
		R visitBinaryExpr(Binary expr);

		R visitLiteralExpr(Literal expr);

		R visitUnaryExpr(Unary expr);

		R visitVariableExpr(Variable expr);

		R visitCallExpr(Call expr);

		R visitIndirectExpr(Indirect expr);
	}

	public static class Binary extends Expr {
		public Binary(Expr left, Operator operator, Expr right, CodeSection section) {
			super(section);
			this.left = left;
			this.operator = operator;
			this.right = right;
		}

		@Override
		public <R> R accept(Visitor<R> visitor) {
			return visitor.visitBinaryExpr(this);
		}

		public final Expr left;
		public final Operator operator;
		public final Expr right;
	}

	public static class Literal extends Expr {
		public Literal(Object value, CodeSection section) {
			super(section);
			this.value = value;
		}

		@Override
		public <R> R accept(Visitor<R> visitor) {
			return visitor.visitLiteralExpr(this);
		}

		public final Object value;
	}

	public static class Unary extends Expr {
		public Unary(Operator operator, Expr right, CodeSection section) {
			super(section);
			this.operator = operator;
			this.right = right;
		}

		@Override
		public <R> R accept(Visitor<R> visitor) {
			return visitor.visitUnaryExpr(this);
		}

		public final Operator operator;
		public final Expr right;
	}

	public static class Variable extends Expr {
		public Variable(String name, CodeSection section) {
			super(section);
			this.name = name;
		}

		@Override
		public <R> R accept(Visitor<R> visitor) {
			return visitor.visitVariableExpr(this);
		}

		public final String name;
	}

	public static class Call extends Expr {
		public final CodeSection call_name_section;

		public Call(String name, List<Expr> arguments, CodeSection section, CodeSection call_name_section) {
			super(section);
			this.name = name;
			this.arguments = arguments;
			this.call_name_section = call_name_section;
		}

		@Override
		public <R> R accept(Visitor<R> visitor) {
			return visitor.visitCallExpr(this);
		}

		public final String name;
		public final List<Expr> arguments;
	}

	public static class Indirect extends Expr {
		/**
		 * Source name. Indicates in which file to look. This name is determined by the
		 * provided name in the import statements.
		 */
		public final String source;
		/**
		 * The expression which will involve indirection to another file.
		 */
		public final Expr indirect;
		/**
		 * The section surrounding the source. For semantic analysis.
		 */
		public final CodeSection source_section;
		
		/**
		 * Variable variant of indirect constructor.
		 * 
		 * @param source
		 * @param indirect
		 * @param section
		 * @param source_section
		 */
		public Indirect(String source, Expr.Variable indirect, CodeSection section, CodeSection source_section) {
			super(section);
			this.source = source;
			this.indirect = indirect;
			this.source_section = source_section;
		}

		public Indirect(String source, Expr.Call indirect, CodeSection section, CodeSection source_section) {
			super(section);
			this.source = source;
			this.indirect = indirect;
			this.source_section = source_section;
		}

		@Override
		public <R> R accept(Visitor<R> visitor) {
			return visitor.visitIndirectExpr(this);
		}
	}

	public abstract <R> R accept(Visitor<R> visitor);
}
