package interpreter;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import edu.data.Outcome;
import edu.data.Stmt;
import edu.data.Token;
import edu.data.VarType;
import edu.error.IError;
import edu.lexer.Lexer;
import edu.parser.Parser;
import edu.pipeline.FileInfo;
import edu.pipeline.FileManager;
import edu.pipeline.Pipeline;
import edu.pipeline.Rootpath;
import edu.pipeline.StatementData;
import visitor.env.GlobalEnvironment;

public class InterpreterPipeline {
	
	public static void runOnFileName(String filename) {
		File f = new File(filename);
		
		if (!f.exists()) {
			System.err.println(String.format("Interpreter immediate failure. Could not resolve file with name '%s'.", filename));
			return;
		}
		
		// this pretty much does everything with checking.
		// statically checks all the relevant files.
		Outcome outcome = Pipeline.runStaticCheck(f);
		
		List<Stmt> statements;
		
		
		if (!outcome.hasManager) {
			// check for errors
			StatementData data = outcome.getStatementData(); // we know this is safe
			if (!data.errors.isEmpty()) {
				System.err.println(String.format("Interpreter had errors checking the file '%s'. Details:", filename));
				for (IError error : data.errors) {
					System.err.println(error);
				}
				
				return; // don't interpret
			}
			
			// otherwise, fall through to interpret!
			statements = data.statements;
			
		} else {
			FileManager<VarType> manager = outcome.getManager();
			
			for (Map.Entry<Rootpath, FileInfo<VarType>> entry : manager) {
				
			}
		}
		// is singleton
		// run checker
		
		// TODO Finish all this
	}
	
	public static GlobalEnvironment<Object> findGlobals(File f) throws RuntimeException {
		Lexer lexer = new Lexer();
		
		lexer.runOnFile(f.getAbsolutePath()); // bubble errors up

		List<Token> token_list = lexer.tokenList;
		Parser parser = new Parser(token_list);


		parser.run(); // bubble errors up
		List<Stmt> statements = parser.statements;
		
		// Checker is ASSUMED to work, since the checker needs to run before interpreter can run.
		
		GlobalValueBuilder gbuilder = new GlobalValueBuilder();
		gbuilder.run(statements);
		if (!gbuilder.visitorErrors.isEmpty()) throw new RuntimeException("Had global construction errors.");
		return gbuilder.globals;
	}
}
